{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MkDocs Material Template","text":"<p>This is a template repository for anyone that wants to use the MkDocs Material Theme.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, first clone this template by clicking on the Green button labeled <code>Use this template</code>. On the new screen, give your repository a name and make sure to check <code>Include all branches</code>. This will make sure that the <code>gh-pages</code> branch is included, or otherwhise publishing the docs to GitHub Pages could cause errors (See Troubleshooting).</p>"},{"location":"#creating-pages","title":"Creating pages","text":"<p>To create new pages, just add new markdown files to the docs folder of the repository and edit them. MkDocs will then turn those into static HTML pages once you build or deploy the pages.</p> <p>The template also has some pre-made settings for you to help you with creating documentation much easier. In the mkdocs.yml will you find many settings that you can alter. Please check the comments and the links they have for more info.</p> <p>It also contains some extensions that might be useful including:</p> <ul> <li>Admonition</li> <li>CodeHilite</li> <li>ToC</li> <li>PyMdown Extensions</li> </ul> <p>You're free to add, edit or remove any extension at your own discretion, but keep in mind that some expansions might caus compatibility issues with others.</p>"},{"location":"#build-pages","title":"Build Pages","text":"<p>To build pages (locally) can you use the <code>mkdocs build</code> command in your prefered command prompt. Note that for the successful execution of this command you have to...</p> <ul> <li>...be in the folder that contains the <code>mkdocs.yml</code></li> <li>...have Python 3.7 installed</li> <li>...have MkDocs and all required dependencies such as Material for MkDocs installed. Note that Material for MkDocs automatically downloads MkDocs and also certain extensions such as the PyMdown Extensions.</li> </ul> <p>MkDocs would now build the HTML in the defined configuration folder for you to use.</p>"},{"location":"#deploy-to-github","title":"Deploy to GitHub","text":"<p>If you want to publish the pages on GitHub Pages can you use the premade workflow for this. This workflow will setup Python, download Material for MkDocs and all its dependencies and deploy the pages to the <code>gh-pages</code> branch to then be viewable under <code>&lt;username&gt;.github.io/&lt;repository&gt;</code> (unless you defined a specific CNAME through a CNAME file in the docs folder).</p> <p>Note that in order for this to work will you need to have a <code>gh-pages</code> branch already made.</p>"},{"location":"#netlify","title":"Netlify","text":"<p>Netlify is an amazing service to build and deploy pages. This template comes with a <code>runtime.txt</code> which is used by Netlify to determine the Python version used (They use an old version of Python... Don't ask why).</p> <p>For more information, please check out their website.</p>"},{"location":"#troubleshooting","title":"Troubleshooting","text":"<p>The deploy action gives me an error when deploying. What is the issue?</p> <p>There can be many issues but the most common ones are that you either don't have a <code>gh-pages</code> branch set or that the <code>requirements.txt</code> file is missing or its content is invalid.</p> <p>Can I alter the overall style of the pages?</p> <p>Yes. Material for MkDocs supports Theme extensions, meaning you can override specific parts of a theme by providing the particula file in a folder and defining this folder as the <code>custom_dir</code> one in the mkdocs.yml. This template ships with a <code>theme</code> folder that can be used for that and you can just uncomment the aforementioned line in the YAML file.</p>"},{"location":"#dependabot","title":"Dependabot","text":"<p>The repository contains a <code>dependabot.yml</code> file inside the <code>.github</code> folder which allows automatic updates through GitHub's Dependabot. It is configured to target both Python dependencies (inside the <code>requirements.txt</code>) and GitHub Actions dependencies, to make sure bot are updated accordingly.</p> <p>Note that it is configured by default to add the <code>Type: Update (Dependency)</code> label and also the <code>Target: Python (pip)</code> label for Python and <code>Target: GitHub Actions</code> label for GitHub Actions Dependencies. Those labels don't exist by default so you have to either create them, or alter the ones in the dependabot.yml (You can also just remove the <code>labels</code> sections).</p>"},{"location":"#credits","title":"Credits","text":"<p>A big thank you goes to the following people/groups:</p> <ul> <li>MkDocs for providing the software, to generate documentation.</li> <li>squidfunk for the MkDocs Material Theme.</li> <li>facelessuser for the PyMdown Extensions.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This template is served under the MIT license. Read the LICENSE file for more info.</p>"},{"location":"Overview/","title":"FAIRsoft indicators","text":""},{"location":"indicators/F1_identity_uniqueness/","title":"F1. Identity Uniqueness","text":"<p>The software has a proper, unique and persistent identifier. The uniqueness of an identifier is a necessary condition to unambiguously refer to that resource, and that resource alone. </p>"},{"location":"indicators/F1_identity_uniqueness/#f11-uniqueness-of-name","title":"F1.1. Uniqueness of name","text":"<p>The software has a unique name to identify it </p> Why should we measure it? How do we measure it? Types it applies to The name is commonly used as the main identifier of a software. Each tool should have a unique name to avoid ambiguities. Different versions of the same software should share a name, but if substantial modifications in the algorithm are done, the identifier should change for the new piece of software. A name is valid. all"},{"location":"indicators/F1_identity_uniqueness/#f12-identifiability-of-version","title":"F1.2. Identifiability of version","text":"<p>There is a scheme to uniquely and properly identify the software version.</p> Why should we measure it? How do we measure it? Types it applies to A version scheme is necessary to refer to a specific release of a software and keep track of the incrementally different versions of the software. A version of the form X.X is considered valid. all"},{"location":"indicators/F2_existence_of_metadata/","title":"F2. Existence of Metadata","text":"<p>The software is described with rich metadata, including scientific applicability. Metadata makes finding through search engines and deciding if a tool is of interest possible.</p>"},{"location":"indicators/F2_existence_of_metadata/#f21-structured-metadata","title":"F2.1. Structured Metadata","text":"<p>Metadata is adjusted to specific metadata formats</p> Why should we measure it? How do we measure it? Types it applies to Specific formats are more machine readable, which increases its findability by search engines At least a source of structured metadata is considered valid. all"},{"location":"indicators/F2_existence_of_metadata/#f22-standardized-metadata","title":"F2.2. Standardized Metadata","text":"<p>Metadata is described using accepted ontologies </p> Why should we measure it? How do we measure it? Types it applies to The same piece of information about a software can be stated in many equivalent forms. Each tool being described with different terminology, with non specified meanings, makes metadata very hard to interpret. Automatic processing is also harder. When searching for a software with certain features, the lack of a consusuate terminology makes the process of searching slow and difficult. EDAM, bioschema all"},{"location":"indicators/F3_searchability/","title":"F3.  Searchability","text":"<p>How software can be found. There are multitude of mechanisms for scientists looking to find specific software</p>"},{"location":"indicators/F3_searchability/#f31-searchability-in-registries","title":"F3.1. Searchability in registries","text":"<p>The software is included in the main software registries.</p> Why should we measure it? How do we measure it? Types it applies to Software registries are the main resource scientists use when searching for software. At least one software registry among the instance sources is considered valid. all"},{"location":"indicators/F3_searchability/#f32-searchability-in-software-repositories","title":"F3.2. Searchability in software repositories","text":"<p>The software can be found in any of the major software repositories e.g. GitHub, GitLab, SourceForge,</p> Why should we measure it? How do we measure it? Types it applies to Software repositories can be an additional resource used by scientists when looking for software An associated software repository is considered valid. all"},{"location":"indicators/F3_searchability/#f33-searchability-in-literature","title":"F3.3. Searchability in literature","text":"<p>The software can be found in specialized literature services e.g. EuropePMC, PubMed, Journals Site, biorxiv</p> Why should we measure it? How do we measure it? Types it applies to Specialized literature is a good reference to find software, especially to discover new software At least one associated publication is considered valid. all"},{"location":"indicators/Findability/","title":"Overview","text":"F1.  Identity Uniqueness The software has a proper, unique and persistent identifier. F1.1 Uniqueness of name The software has a unique name to identify it F1.2. Identifiability of version There is a scheme to uniquely and properly identify the software version.  F2. Existence of Metadata  The software is described with rich metadata, including scientific applicability. F2.1. Structured Metadata Metadata is adjusted to specific metadata formats F2.2. Standardized Metadata Metadata is described using accepted ontologies  F3. Searchability  How software can be found.  F3.1. Searchability in registries The software is included in the main software registries. F3.2. Searchability in software repositories The software is included in the main software repositories. F3.3. Searchability in search engines The software is indexed by search engines."}]}